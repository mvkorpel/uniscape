% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutate.R
\name{string_mutate}
\alias{string_mutate}
\title{Mutate parts of strings}
\usage{
string_mutate(x, first = 1L, last = -1L, mutate_func = function(x) x,
  row_first = seq_along(x), row_last = row_first, check = TRUE, ...)
}
\arguments{
\item{x}{a \code{character} vector containing text to be mutated.
Interpreted as lines (rows) of text.}

\item{first}{a \code{numeric} vector. First character of substring(s)
to be changed.}

\item{last}{a \code{numeric} vector. Last character of substring(s)
to be changed.}

\item{mutate_func}{a function that accepts a single \code{character}
string as the first argument and returns something coercible to a string.
Used for mutating the substring(s) indicated by \code{first}, \code{last},
\code{row_first}, and \code{row_last}.}

\item{row_first}{on which row (\code{numeric} index to \code{x}) does each
substring begin?}

\item{row_last}{on which row (\code{numeric}) does each substring end?}

\item{check}{a \code{logical} flag. Check the arguments?}

\item{\dots}{arguments passed to \code{mutate_func}.}
}
\value{
a \code{list} with two components:
  \item{\code{"text"}}{the modified text as a \code{character} vector. }
  \item{\code{"ranges"}}{a \code{data.frame} as returned by
  \code{\link{find_strings}}, but describing the location of each
  \emph{modified} string \emph{in the output}. Sections left unchanged by
  \code{mutate_func} are not reported.}
}
\description{
Mutates substrings of the input. Also reports the parts that changed.
}
\details{
Arguments \code{first}, \code{last}, \code{row_first}, and \code{row_last}
must have a common length or one item only.
}
\section{Note}{
 The mutation function should preferably operate
  on a character-by-character basis. This is because strings streched across
  multiple items in \code{x} are mutated in pieces, and \emph{not} combined
  before mutation. See \sQuote{Examples}.
}

\examples{
first <- seq(from = 1, to = length(letters), by = 8)
last <- first + seq(to = 0, by = -2, length.out = length(first))
a_to_z <- paste0(letters, collapse = "")
string_mutate(a_to_z, first, last, toupper)

## Logically operating on one range stretching across two rows,
## but the rows are processed separately.
string_mutate(c("abc", "def"), 3, 1, nchar, row_first = 1, row_last = 2)
}
